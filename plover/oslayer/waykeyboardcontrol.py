"""Keyboard capture and control on Wayland.

This module provides an interface for capturing and emulating keyboard events
on Wayland compositors that support the 'virtual_keyboard_unstable_v1' and
'input_method_unstable_v2' protocols (that is, wlroots-based compositors
like Sway, as of January 2022).
"""

import os
import time
import select
from threading import Thread
from pywayland.client.display import Display

# Protocol modules generated from XML description files at build time
from plover.oslayer.wayland.wayland.wl_seat import WlSeat
from plover.oslayer.wayland.input_method_unstable_v2.zwp_input_method_manager_v2 \
    import ZwpInputMethodManagerV2
from plover.oslayer.wayland.virtual_keyboard_unstable_v1.zwp_virtual_keyboard_manager_v1 \
    import ZwpVirtualKeyboardManagerV1

from plover.oslayer.xkeyboardcontrol import KEYCODE_TO_KEY, KEY_TO_KEYSYM
from plover.key_combo import parse_key_combo, add_modifiers_aliases


# Taken from the default XKB modifier mapping
MOD_NAME_TO_INDEX = {
    'shift_l': 0,
    'shift_r': 0,
    'lock': 1,
    'caps_lock': 1,
    'control_l': 2,
    'control_r': 2,
    'mod1': 3,
    'alt_l': 3,
    'meta_l': 3,
    'alt_r': 3,
    'meta_r': 3,
    'mod2': 4,
    'num_lock': 4,
    'mod3': 5,
    'mod4': 6,
    'super_l': 6,
    'super_r': 6,
    'hyper_l': 6,
    'hyper_r': 6,
    'mod5': 7,
    'iso_level3_shift': 7,
    'mode_switch': 7,
}
add_modifiers_aliases(MOD_NAME_TO_INDEX)

XKB_KEYCODE_OFFSET = 8
PLOVER_TAG = '<PLVR>'


def keymap_generate(keysyms):
    """Generate a keymap that can send the given list of keysyms.

    Argument:

    keysyms -- List of keysyms to support.

    Returns: A file descriptor for the new keymap, and the new keymap’s size.
    """
    keycodes = '\n'.join([
        # Special keycode recognized by the keyboard capture class to
        # avoid processing generated keys
        f'{PLOVER_TAG} = {XKB_KEYCODE_OFFSET + len(keysyms)};'
    ] + [
        f'<C{keycode}> = {XKB_KEYCODE_OFFSET + keycode};'
        for keycode, _ in enumerate(keysyms)
    ])
    symbols = '\n'.join([
        f'key {PLOVER_TAG} {{[]}};'
    ] + [
        f'key <C{keycode}> {{[{keysym}]}};' \
        for keycode, keysym in enumerate(keysyms)
    ])
    keymap = f'''xkb_keymap {{
xkb_keycodes {{
minimum = {XKB_KEYCODE_OFFSET};
maximum = {XKB_KEYCODE_OFFSET + len(keysyms)};
{keycodes}
}};
xkb_types {{}};
xkb_compatibility {{}};
xkb_symbols {{
{symbols}
}};
}};'''
    fd = os.memfd_create('emulated_keymap.xkb')
    os.truncate(fd, len(keymap))
    file = open(fd, 'w', closefd=False)
    file.write(keymap)
    file.flush()
    return fd, len(keymap)


def keymap_is_generated(fd):
    """Check whether a keymap was generated from this module."""
    file = open(fd, closefd=False)
    keymap = file.read()
    return keymap.find(PLOVER_TAG) >= 0


class KeyboardCapture:
    """Listen to keyboard press and release events.

    This uses the 'input_method_unstable_v2' protocol to grab the Wayland
    keyboard. This grab is global and unconditional, therefore a virtual
    keyboard input is also created (using the 'virtual_keyboard_unstable_v1'
    protocol) to forward events that do not need to be captured by Plover.
    Note that this grab will also capture events generated by the
    KeyboardEmulation class, those events need to be actively filtered out
    to avoid infinite feedback loops.
    """
    def __init__(self):
        # Callbacks that receive keypresses
        self.key_down = lambda key: None
        self.key_up = lambda key: None

        # True if the event loop is running
        self._running = False
        self._loop_thread = None

        # Global Wayland objects
        self._display = None
        self._seat = None
        self._keyboard = None

        # True if the keyboard has been grabbed
        self._grabbed = False

        # Keyboard grab and virtual keyboard objects
        self._input_method_manager = None
        self._input_method = None
        self._grabbed_keyboard = None
        self._virtual_keyboard_manager = None
        self._virtual_keyboard = None

        # Current modifier state, depressed, latched and locked
        self._mod_state = (0, 0, 0)

        # True if the next received keypresses should be ignored
        # because they are generated by KeyboardEmulation
        self._is_generated = False

        # Set of keys to capture and transmit to Plover - other keys
        # are forwarded to the client transparently
        self._suppressed_keys = set()

    def start(self):
        """Connect to the Wayland compositor and start the event loop."""
        if not self._running:
            self._display = Display()
            self._display.connect()

            # Query protocols available in the current compositor
            reg = self._display.get_registry()
            reg.dispatcher['global'] = self._on_registry_global
            self._display.roundtrip()

            for obj, interface in (
                (self._seat, WlSeat),
                (self._input_method_manager, ZwpInputMethodManagerV2),
                (self._virtual_keyboard_manager, ZwpVirtualKeyboardManagerV1),
            ):
                if not obj:
                    raise RuntimeError(f'Cannot capture keyboard events: your \
Wayland compositor does not support the \'{interface.name}\' interface')

            # Wait for an active keyboard to be ready before grabbing (in some
            # cases, there might not be any active keyboard, for example if the
            # last active keyboard was just unplugged - trying to grab the
            # keyboard in this scenario would crash the compositor)
            self._keyboard = self._seat.get_keyboard()
            self._keyboard.dispatcher['keymap'] = self._on_keyboard_ready

            self._running = True
            self._loop_thread = Thread(target=self._event_loop)
            self._loop_thread.start()

    def cancel(self):
        """Cancel grabbing the keyboard and free resources."""
        if self._running:
            self._running = False
            self._loop_thread.join()
            self._loop_thread = None

            if self._grabbed:
                self._grabbed = False
                self._virtual_keyboard.destroy()
                self._virtual_keyboard = None
                self._input_method.destroy()
                self._input_method = None
                self._grabbed_keyboard = None
                self._virtual_keyboard_manager = None
                self._input_method_manager = None

            if self._keyboard:
                self._keyboard.release()
                self._keyboard = None

            if self._seat:
                self._seat.release()
                self._seat = None

            self._display.disconnect()
            self._display = None

    def _event_loop(self):
        """Read incoming events repeatedly."""
        fd = self._display.get_fd()

        while self._running:
            # Send any remaining requests
            self._display.flush()

            # Wait for events from the server and process them
            read, _, _ = select.select((fd,), (), (), 1)
            if read: self._display.dispatch(block=True)

    def _on_registry_global(self, obj, name, interface, version):
        """Listener for global objects advertised by the Wayland compositor."""
        if interface == WlSeat.name:
            self._seat = obj.bind(name, WlSeat, version)
        elif interface == ZwpInputMethodManagerV2.name:
            self._input_method_manager = \
                obj.bind(name, ZwpInputMethodManagerV2, version)
        elif interface == ZwpVirtualKeyboardManagerV1.name:
            self._virtual_keyboard_manager = \
                obj.bind(name, ZwpVirtualKeyboardManagerV1, version)

    def _on_keyboard_ready(self, _, fmt, fd, size):
        if not self._grabbed:
            # Now that the source keyboard is ready, try grabbing its events
            self._grabbed = True
            self._input_method = \
                self._input_method_manager.get_input_method(self._seat)
            self._grabbed_keyboard = self._input_method.grab_keyboard()
            self._virtual_keyboard = \
                self._virtual_keyboard_manager.create_virtual_keyboard( \
                    self._seat)

            self._grabbed_keyboard.dispatcher['keymap'] = self._on_grab_keymap
            self._grabbed_keyboard.dispatcher['modifiers'] = \
                self._on_grab_modifiers
            self._grabbed_keyboard.dispatcher['key'] = self._on_grab_key

        os.close(fd)

    def _on_grab_keymap(self, _, fmt, fd, size):
        """Callback for when the active keymap changes."""
        self._is_generated = fmt == 1 and keymap_is_generated(fd)
        self._virtual_keyboard.keymap(fmt, fd, size)
        self._display.flush()
        os.close(fd)

    def _on_grab_key(self, _, serial, origtime, keycode, state):
        """Callback for when a new key event arrives."""
        key = KEYCODE_TO_KEY.get(keycode + 8)

        if not self._is_generated and key in self._suppressed_keys and \
                self._mod_state == (0, 0, 0):
            # Signal and suppress changes for watched keys
            if state == 1: self.key_down(key)
            else: self.key_up(key)
        else:
            # Forward other keys unchanged
            self._virtual_keyboard.key(origtime, keycode, state)
            self._display.flush()

    def _on_grab_modifiers(self, _, serial, depressed, latched, locked, layout):
        """Callback for when the set of active modifiers changes."""
        self._mod_state = (depressed, latched, locked)
        self._virtual_keyboard.modifiers(depressed, latched, locked, layout)
        self._display.flush()

    def suppress_keyboard(self, keys=()):
        """Change the set of keys to capture."""
        self._suppressed_keys = set(keys)


class KeyboardEmulation:
    """Emulate keyboard events to send strings on Wayland.

    This emulation layer uses the 'virtual_keyboard_unstable_v1' protocol.
    Since the protocol allows using any XKB layout, a new layout is generated
    each time a string needs to be sent, containing just the needed symbols.
    This makes the emulation independent of the user’s current keyboard layout.
    To signal emulated events to KeyboardCapture, a special tag is inserted in
    generated XKB layouts.
    """
    def __init__(self):
        # True if the required interfaces for sending key events are setup
        self._ready = False

        # Global Wayland objects
        self._display = Display()
        self._display.connect()
        self._seat = None

        # Virtual keyboard objects
        self._virtual_keyboard_manager = None
        self._virtual_keyboard = None

        # Query protocols available in the current compositor
        reg = self._display.get_registry()
        reg.dispatcher['global'] = self._on_registry_global
        self._display.roundtrip()

        for obj, interface in (
            (self._seat, WlSeat),
            (self._virtual_keyboard_manager, ZwpVirtualKeyboardManagerV1),
        ):
            if not obj:
                raise RuntimeError(f'Cannot emulate keyboard events: your \
Wayland compositor does not support the \'{interface.name}\' interface')

        self._virtual_keyboard = \
            self._virtual_keyboard_manager.create_virtual_keyboard(self._seat)
        self._ready = True

    def close(self, type, value, traceback):
        """Destroy the virtual keyboard and free resources."""
        self._ready = False

        if self._virtual_keyboard:
            self._virtual_keyboard.destroy()
            self._virtual_keyboard = None

        if self._seat:
            self._seat.release()
            self._seat = None

        if self._display:
            self._display.disconnect()
            self._display = None

    def _on_registry_global(self, obj, name, interface, version):
        """Listener for global objects advertised by the Wayland compositor."""
        if interface == WlSeat.name:
            self._seat = obj.bind(name, WlSeat, version)
        elif interface == ZwpVirtualKeyboardManagerV1.name:
            self._virtual_keyboard_manager = \
                obj.bind(name, ZwpVirtualKeyboardManagerV1, version)

    def _send_keymap(self, keysyms):
        """Set virtual keymap to support a given list of keysyms."""
        fd, size = keymap_generate(keysyms)
        self._virtual_keyboard.keymap(1, fd, size)
        self._display.flush()
        os.close(fd)

    def _send_key(self, keycode, state):
        """Emulate a single keypress."""
        timestamp = time.thread_time_ns() // (10 ** 3)
        self._virtual_keyboard.key(timestamp, keycode, state)

    def _send_modifiers(self, mods):
        """Emulate changing the active modifiers."""
        self._virtual_keyboard.modifiers(
            mods_depressed=mods,
            mods_latched=0,
            mods_locked=0,
            group=0,
        )

    def send_string(self, string):
        """Emulate a complete string."""
        if not self._ready:
            raise RuntimeError('Cannot send string: keyboard emulation \
is not available')

        letterset = list(set(string))
        keysyms = [f'U{ord(letter):04X}' for letter in letterset]
        self._send_keymap(keysyms)

        for letter in string:
            self._send_key(letterset.index(letter), 1)
            self._send_key(letterset.index(letter), 0)

        self._display.flush()

    def send_backspaces(self, count):
        """Emulate a sequence of backspaces."""
        if not self._ready:
            raise RuntimeError('Cannot send backspaces: keyboard emulation \
is not available')

        self._send_keymap(['BackSpace'])

        for _ in range(count):
            self._send_key(0, 1)
            self._send_key(0, 0)

        self._display.flush()

    def send_key_combination(self, combo_string):
        """Emulate a key combo."""
        combo = parse_key_combo(combo_string)

        keyset = list(set([
            key[0] for key in combo
            if key[0] not in MOD_NAME_TO_INDEX
        ]))
        keysyms = [str(KEY_TO_KEYSYM[key]) for key in keyset]
        self._send_keymap(keysyms)

        mods = 0

        for key, state in combo:
            if key in MOD_NAME_TO_INDEX:
                index = MOD_NAME_TO_INDEX[key]
                if state: mods |= (1 << index)
                else: mods &= ~(1 << index)
                self._send_modifiers(mods)
            else:
                self._send_key(keyset.index(key), state)

        self._display.flush()
